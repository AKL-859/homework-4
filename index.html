<!-- Code from d3-graph-gallery.com -->
<!DOCTYPE html>
<meta charset="utf-8" />

<link rel="stylesheet" href="worldmapstyle.css" />

<!-- Load d3.js and the geo projection plugin -->
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

<script src="./datasets/brfo.js"></script>

<head>
  <title>Homework #4: Innovative Visualization Design</title>
</head>

<body>
  <div style="background-color: white; width: 100%; height: 100vh">
    <div style="width: 40%; height: 100vh; float: left; padding: 20px">
      <div class="mapSelection">
        <div
          id="is-classA"
          class="toggleBox is-classA"
          onclick="hideLabels('.bigFootLabel_ClassA','is-classA','rgba(0, 123, 255, 0.125)')"
        >
          <div class="fadeInUp">
            <h5>Group A</h5>
            <h1>1895</h1>
          </div>
          <div class="groupALine"></div>
        </div>
        <div
          id="is-classB"
          class="toggleBox is-classB"
          onclick="hideLabels('.bigFootLabel_ClassB','is-classB','rgba(255, 7, 58, 0.125)')"
        >
          <div class="fadeInUp">
            <h5>Group B</h5>
            <h1>1896</h1>
          </div>
          <div class="groupBLine"></div>
        </div>
        <div
          id="is-classC"
          class="toggleBox is-classC"
          onclick="hideLabels('.bigFootLabel_ClassC','is-classC','rgba(40, 167, 69, 0.125)')"
        >
          <div class="fadeInUp">
            <h5>Group C</h5>
            <h1>18</h1>
          </div>
          <div class="groupCLine"></div>
        </div>
        <div
          id="is-classD"
          class="toggleBox is-classD"
          onclick="hideLabels('.allLabels','is-classD','rgba(108, 117, 125, 0.125)')"
        >
          <div class="fadeInUp">
            <h5>All</h5>
            <h1>3810</h1>
          </div>
          <div class="groupDLine"></div>
        </div>
      </div>
      <div id="statesTable"></div>
    </div>

    <div
      class="mapSection"
      style="background-color: white; width: 60%; height: 100vh; float: left"
    >
      <div id="my_dataviz">
        <h4
          style="color: black; align-self: center; margin-top: 18px"
          class="fadeInDown"
        >
          Choropleth map of BIG Foot classes in the USA with pin location based
          on left side control panel (1950-2017)
        </h4>
        <h5
          class="fadeInDown"
          style="
            color: black;
            align-self: center;
            font-weight: 300;
            background-color: rgba(0, 255, 0, 0.25);
            border-radius: 5px;
            padding: 4px;
          "
        >
          Tip: Hover on the glyphs for more info.
        </h5>
        <!-- <button onclick="labelColor()">Change Color by Season</button>
        <button onclick="revertlabelColor()">Change Color by Class</button> -->

        <div class="circleLabelsGroup" style="display: flex">
          <div
            class="circleLabel is-classA"
            onclick="hideLabels('.bigFootLabel_ClassA','is-classA','rgba(0, 123, 255, 0.125)')"
          ></div>
          <div
            class="circleLabel is-classB"
            onclick="hideLabels('.bigFootLabel_ClassB','is-classB','rgba(255, 7, 58, 0.125)')"
          ></div>
          <div
            class="circleLabel is-classC"
            onclick="hideLabels('.bigFootLabel_ClassC','is-classC','rgba(40, 167, 69, 0.125)')"
          ></div>
          <div
            class="circleLabel is-classD"
            onclick="hideLabels('.allLabels','is-classD','rgba(108, 117, 125, 0.125)')"
          ></div>
        </div>
      </div>
      <svg id="MapLabel" width="232" height="16"></svg>
      <div id="pieCharts">
        <h1 class="subHeading fadeInDown">
          Bigfoot Selected Classification by US Census Region
        </h1>
      </div>
      <div id="heatMaps">
        <h1 class="subHeading fadeInDown">
          Bigfoot Selected Classification by Season
        </h1>
      </div>
    </div>
  </div>
</body>

<script>
  var states,
    stateCountA,
    stateCountB,
    stateCountC,
    stateCount,
    dataGeoGlobal,
    color,
    svgP;

  // Color Scale
  var myColor = d3
    .scaleSequential()
    .interpolator(d3.interpolateGreys)
    .domain([1, 257]);

  var myColorA = d3
    .scaleSequential()
    .interpolator(d3.interpolateBlues)
    .domain([1, 257]);

  var myColorB = d3
    .scaleSequential()
    .interpolator(d3.interpolateReds)
    .domain([1, 257]);

  var myColorC = d3
    .scaleSequential()
    .interpolator(d3.interpolateGreens)
    .domain([1, 257]);
  // Size
  var width = document
    .querySelector(".mapSection")
    .getBoundingClientRect().width;
  var height = 575;

  const USA_states = [
    "Alabama",
    "Alaska",
    "Arizona",
    "Arkansas",
    "California",
    "Colorado",
    "Connecticut",
    "Delaware",
    "Florida",
    "Georgia",
    "Hawaii",
    "Idaho",
    "Illinois",
    "Indiana",
    "Iowa",
    "Kansas",
    "Kentucky",
    "Louisiana",
    "Maine",
    "Maryland",
    "Massachusetts",
    "Michigan",
    "Minnesota",
    "Mississippi",
    "Missouri",
    "Montana",
    "Nebraska",
    "Nevada",
    "New Hampshire",
    "New Jersey",
    "New Mexico",
    "New York",
    "North Carolina",
    "North Dakota",
    "Ohio",
    "Oklahoma",
    "Oregon",
    "Pennsylvania",
    "Rhode Island",
    "South Carolina",
    "South Dakota",
    "Tennessee",
    "Texas",
    "Utah",
    "Vermont",
    "Virginia",
    "Washington",
    "West Virginia",
    "Wisconsin",
    "Wyoming",
  ];

  // The svg
  var svg = d3
    .select("#my_dataviz")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

  function hideLabels(label, selectedId, classColor) {
    const allLabels = [
      ".bigFootLabel_ClassA",
      ".bigFootLabel_ClassB",
      ".bigFootLabel_ClassC",
      ".bigFootLabel_ClassD",
    ];
    const allClasses = [
      { "is-classA": "rgba(0, 123, 255, 0.125)" },
      { "is-classB": "rgba(255, 7, 58, 0.125)" },
      { "is-classC": "rgba(40, 167, 69, 0.125)" },
      { "is-classD": "rgba(108, 117, 125, 0.125)" },
    ];

    // hide all other labels

    if (label !== ".allLabels") {
      allLabels.forEach(function (d) {
        if (d === label) {
          d3.selectAll(d).attr("visibility", "visible");
        } else {
          d3.selectAll(d).attr("visibility", "hidden");
        }
      });
    } else {
      allLabels.forEach(function (d) {
        d3.selectAll(d).attr("visibility", "visible");
      });
    }

    d3.selectAll("#pieChart").remove();
    d3.selectAll("#bySeasonSVG").remove();

    if (label === ".bigFootLabel_ClassA") {
      svg
        .selectAll("path")
        .data(dataGeoGlobal.features)
        .attr("fill", function (d) {
          var opacity = stateCountA[d.properties["NAME"]];
          return myColorA(opacity);
        });

      // drawScale("MapLabel", d3.interpolateBlues);
      drawPie(censusDataAll["ClassA"], "ClassA");
    } else if (label === ".bigFootLabel_ClassB") {
      svg
        .selectAll("path")
        .data(dataGeoGlobal.features)
        .attr("fill", function (d) {
          var opacity = stateCountB[d.properties["NAME"]];
          return myColorB(opacity);
        });

      drawPie(censusDataAll["ClassB"], "ClassB");
    } else if (label === ".bigFootLabel_ClassC") {
      svg
        .selectAll("path")
        .data(dataGeoGlobal.features)
        .attr("fill", function (d) {
          var opacity = stateCountC[d.properties["NAME"]];
          return myColorC(opacity);
        });

      drawPie(censusDataAll["ClassC"], "ClassC");
    } else if (label === ".allLabels") {
      svg
        .selectAll("path")
        .data(dataGeoGlobal.features)
        .attr("fill", function (d) {
          var opacity = stateCount[d.properties["NAME"]];
          return myColor(opacity);
        });

      drawPie(censusDataAll["allClasses"], "ClassD");
    }

    // set background color of selected label and reset others to default
    allClasses.forEach(function (classObj) {
      const classKey = Object.keys(classObj)[0];
      const classValue = classObj[classKey];
      if (classKey === selectedId) {
        document.getElementById(selectedId).style.backgroundColor = classColor;
      } else {
        document.getElementById(classKey).style.backgroundColor = "transparent";
      }
    });
  }

  // Map and projection
  var projection = d3
    // .geoAlbersUsa()
    .geoMercator()
    .center([-96, 38]) // GPS of location to zoom on
    .scale(width * 0.95)
    .translate([width / 2, height / 2]);

  d3.queue()
    .defer(d3.json, "./datasets/maps/USA_states.json")
    .defer(d3.csv, "./datasets/brfo.csv")
    .await(ready);

  function getYearAndSeason(dateString) {
    const date = new Date(dateString);
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    let season = "";
    let color = "";

    if ((month >= 0 && month <= 2) || month === 12) {
      color = "#FEF8FA";
      season = "winter";
    } else if (month >= 3 && month <= 5) {
      color = "#D6F1C6";
      season = "spring";
    } else if (month >= 6 && month <= 8) {
      color = "#F9CC87";
      season = "summer";
    } else if (month >= 9 && month <= 11) {
      color = "#C9F1FD";
      season = "fall";
    }

    return { color, season, year };
  }

  var states = [];
  var stateName;

  // set the dimensions and margins of the basic line graph
  var margin = { top: 2, right: 2, bottom: 2, left: 2 },
    widthLine =
      document.querySelector(".groupALine").getBoundingClientRect().width -
      margin.left -
      margin.right,
    heightLine =
      document.querySelector(".groupALine").getBoundingClientRect().width -
      20 -
      margin.top -
      margin.bottom;

  // append the svg object to the body of the page
  var svgLineA = d3
    .select(".groupALine")
    .append("svg")
    .attr("width", widthLine + margin.left + margin.right)
    .attr("height", heightLine + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var svgLineB = d3
    .select(".groupBLine")
    .append("svg")
    .attr("width", widthLine + margin.left + margin.right)
    .attr("height", heightLine + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var svgLineC = d3
    .select(".groupCLine")
    .append("svg")
    .attr("width", widthLine + margin.left + margin.right)
    .attr("height", heightLine + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var svgLineD = d3
    .select(".groupDLine")
    .append("svg")
    .attr("width", widthLine + margin.left + margin.right)
    .attr("height", heightLine + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var dataset;

  function miniGraph(dataset) {
    const occurrenceByYearAndClassification = {};

    for (const data of dataset) {
      const year = data.timestamp.substring(0, 4);
      const classification = data.classification;

      if (!occurrenceByYearAndClassification[year]) {
        occurrenceByYearAndClassification[year] = {};
      }

      if (!occurrenceByYearAndClassification[year][classification]) {
        occurrenceByYearAndClassification[year][classification] = 1;
      } else {
        occurrenceByYearAndClassification[year][classification]++;
      }
    }

    // Format the dataset
    const dataA = Object.keys(occurrenceByYearAndClassification).map((year) => {
      return {
        year: +year,
        count: occurrenceByYearAndClassification[year]["Class A"] || 0,
      };
    });

    const dataB = Object.keys(occurrenceByYearAndClassification).map((year) => {
      return {
        year: +year,
        count: occurrenceByYearAndClassification[year]["Class B"] || 0,
      };
    });

    const dataC = Object.keys(occurrenceByYearAndClassification).map((year) => {
      return {
        year: +year,
        count: occurrenceByYearAndClassification[year]["Class C"] || 0,
      };
    });

    const dataD = Object.keys(occurrenceByYearAndClassification).map((year) => {
      return {
        year: +year,
        count:
          occurrenceByYearAndClassification[year]["Class A"] ||
          occurrenceByYearAndClassification[year]["Class B"] ||
          occurrenceByYearAndClassification[year]["Class C"],
      };
    });

    const x = d3.scaleLinear().range([0, widthLine]);
    const y = d3.scaleLinear().range([heightLine, 0]);
    const yC = d3.scaleLinear().range([heightLine, 0]);

    const line = d3
      .line()
      .x((d) => x(d.year))
      .y((d) => y(d.count));

    const dataA1 = dataA.filter((d) => {
      return d.year > 1950;
    });

    const dataB1 = dataB.filter((d) => {
      return d.year > 1950;
    });

    const dataC1 = dataC.filter((d) => {
      return d.year > 1950;
    });

    const dataD1 = dataD.filter((d) => {
      return d.year > 1950;
    });

    x.domain(d3.extent(dataA1, (d) => d.year));
    y.domain([0, d3.max(dataA1, (d) => d.count)]);
    yC.domain([0, d3.max(dataC1, (d) => d.count)]);
    // Add the x-axis
    svgLineA.append("g").attr("transform", "translate(0," + heightLine + ")");

    svgLineA
      .append("path")
      .datum(dataA1)
      .attr("fill", "none")
      .attr("stroke", "#007bff99")
      .attr("stroke-width", 2.5)
      .attr(
        "d",
        d3
          .line()
          .x(function (d) {
            return x(d.year);
          })
          .y(function (d) {
            return y(d.count);
          })
          .curve(d3.curveBasis)
      )
      .attr("stroke-dasharray", function () {
        return this.getTotalLength();
      })
      .attr("stroke-dashoffset", function () {
        return this.getTotalLength();
      })
      .transition()
      .duration(3000)
      .ease(d3.easeCubicIn)
      .attr("stroke-dashoffset", 0);

    svgLineA
      .append("circle")
      .datum(dataA1[dataA1.length - 1])
      .attr("cx", function (d) {
        return x(d.year - 2);
      })
      .attr("cy", function (d) {
        return y(d.count + 1);
      })
      .attr("r", 3.5)
      .attr("fill", "#007bff");

    svgLineB
      .append("path")
      .datum(dataB1)
      .attr("fill", "none")
      .attr("stroke", "#ff073a99")
      .attr("stroke-width", 2.5)
      .attr(
        "d",
        d3
          .line()
          .x(function (d) {
            return x(d.year);
          })
          .y(function (d) {
            return y(d.count);
          })
          .curve(d3.curveBasis)
      )
      .attr("stroke-dasharray", function () {
        return this.getTotalLength();
      })
      .attr("stroke-dashoffset", function () {
        return this.getTotalLength();
      })
      .transition()
      .duration(3000)
      .ease(d3.easeCubicIn)
      .attr("stroke-dashoffset", 0);

    svgLineB
      .append("circle")
      .datum(dataA1[dataA1.length - 1])
      .attr("cx", function (d) {
        return x(d.year - 2);
      })
      .attr("cy", function (d) {
        return y(d.count + 1);
      })
      .attr("r", 3.5)
      .attr("fill", "#ff073a99");

    svgLineC
      .append("path")
      .datum(dataC1)
      .attr("fill", "none")
      .attr("stroke", "#28a74599")
      .attr("stroke-width", 2.5)
      .attr(
        "d",
        d3
          .line()
          .x(function (d) {
            return x(d.year);
          })
          .y(function (d) {
            return yC(d.count);
          })
          .curve(d3.curveBasis)
      )
      .attr("stroke-dasharray", function () {
        return this.getTotalLength();
      })
      .attr("stroke-dashoffset", function () {
        return this.getTotalLength();
      })
      .transition()
      .duration(3000)
      .ease(d3.easeCubicIn)
      .attr("stroke-dashoffset", 0);

    svgLineC
      .append("circle")
      .datum(dataA1[dataA1.length - 1])
      .attr("cx", function (d) {
        return x(d.year - 2);
      })
      .attr("cy", function (d) {
        return y(d.count + 1);
      })
      .attr("r", 3.5)
      .attr("fill", "#28a74599");

    svgLineD
      .append("path")
      .datum(dataD1)
      .attr("fill", "none")
      .attr("stroke", "#6c757d99")
      .attr("stroke-width", 2.5)
      .attr(
        "d",
        d3
          .line()
          .x(function (d) {
            return x(d.year);
          })
          .y(function (d) {
            return y(d.count);
          })
          .curve(d3.curveBasis)
      )
      .attr("stroke-dasharray", function () {
        return this.getTotalLength();
      })
      .attr("stroke-dashoffset", function () {
        return this.getTotalLength();
      })
      .transition()
      .duration(3000)
      .ease(d3.easeCubicIn)
      .attr("stroke-dashoffset", 0);

    svgLineD
      .append("circle")
      .datum(dataA1[dataA1.length - 1])
      .attr("cx", function (d) {
        return x(d.year - 2);
      })
      .attr("cy", function (d) {
        return y(d.count + 1);
      })
      .attr("r", 3.5)
      .attr("fill", "#6c757d99");
  }

  var censusDataAll = {
    allClasses: { West: 1260, South: 1270, Midwest: 937, Northeast: 166 },
    ClassA: { West: 571, South: 713, Midwest: 481, Northeast: 66 },
    ClassB: { West: 680, South: 555, Midwest: 448, Northeast: 100 },
    ClassC: { West: 9, South: 2, Midwest: 8, Northeast: 0 },
  };

  function drawPie(dataSet, group) {
    //for SVG by season
    d3.xml(`./datasets/svgFiles/${group}.svg`)
      .mimeType("image/svg+xml")
      .get(function (error, xml) {
        if (error) throw error;

        var div = d3.select("#heatMaps");

        var svgBigFoot = div.node().appendChild(xml.documentElement);

        d3.select(svgBigFoot).attr("id", "bySeasonSVG");
      });

    var container = d3.select("#pieCharts");

    var containerWidth = parseInt(container.style("width"));
    var containerHeight = parseInt(container.style("height"));

    var widthP = containerWidth;
    heightP = containerWidth / 2;
    marginP = 0;

    var radius = Math.min(widthP, heightP) / 2 - marginP;

    svgP = d3
      .select("#pieCharts")
      .append("svg")
      .attr("id", "pieChart")
      .attr("width", widthP)
      .attr("height", heightP)
      .append("g")
      .attr("transform", "translate(" + widthP / 2 + "," + heightP / 2 + ")");

    var censusData = dataSet;

    // set the color scale
    var colorP = d3
      .scaleOrdinal()
      .domain(["West", "South", "Midwest", "Northeast"])
      .range(d3.schemeDark2);

    var pie = d3
      .pie()
      .sort(null)
      .value(function (d) {
        return d.value;
      });
    var data_ready = pie(d3.entries(censusData));

    var arc = d3
      .arc()
      .innerRadius(radius * 0.5)
      .outerRadius(radius * 0.8);

    var outerArc = d3
      .arc()
      .innerRadius(radius * 0.9)
      .outerRadius(radius * 0.9);

    svgP
      .selectAll("allSlices")
      .data(data_ready)
      .enter()
      .append("path")
      .attr("d", arc)
      .attr("fill", function (d) {
        return colorP(d.data.key);
      })
      .attr("stroke", "white")
      .style("stroke-width", "2px")
      .style("opacity", 0.7);

    svgP
      .selectAll("allPolylines")
      .data(data_ready)
      .enter()
      .append("polyline")
      .attr("stroke", "black")
      .style("fill", "none")
      .attr("stroke-width", 1)
      .attr("points", function (d) {
        var posA = arc.centroid(d);
        var posB = outerArc.centroid(d);
        var posC = outerArc.centroid(d);
        var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;
        posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1);
        return [posA, posB, posC];
      });

    svgP
      .selectAll("allLabels")
      .data(data_ready)
      .enter()
      .append("text")
      .text(function (d) {
        return `${d.data.key + "(" + d.data.value + ")"}`;
      })
      .attr("transform", function (d) {
        var pos = outerArc.centroid(d);
        var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;
        pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);
        return "translate(" + pos + ")";
      })
      .style("text-anchor", function (d) {
        var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;
        return midangle < Math.PI ? "start" : "end";
      })
      .style("font-size", "14px")
      .style("font-family", "archia");
  }

  function ready(error, dataGeo, data) {
    dataset = data;
    dataGeoGlobal = dataGeo;
    miniGraph(dataset);

    const stateData = data.reduce((acc, obj) => {
      const state = obj.state;
      const classification = obj.classification;

      if (!acc[state]) {
        acc[state] = { total: 0, classificationCount: {} };
      }

      acc[state].total++;

      if (!acc[state].classificationCount[classification]) {
        acc[state].classificationCount[classification] = 0;
      }

      acc[state].classificationCount[classification]++;

      return acc;
    }, {});

    // --------------------------------------------------------------------
    const stateData1 = data.reduce((acc, obj) => {
      const state = obj.state;
      const classification = obj.classification;
      const season = getSeason(obj.timestamp);

      if (!acc[state]) {
        acc[state] = {
          total: 0,
          classACount: 0,
          classBCount: 0,
          classCCount: 0,
          seasonCount: { Spring: 0, Summer: 0, Fall: 0, Winter: 0 },
        };
      }

      acc[state].total++;

      if (classification === "Class A") {
        acc[state].classACount++;
      } else if (classification === "Class B") {
        acc[state].classBCount++;
      } else if (classification === "Class C") {
        acc[state].classCCount++;
      }

      acc[state].seasonCount[season]++;

      return acc;
    }, {});

    function getSeason(timestamp) {
      const date = new Date(timestamp);
      const month = date.getMonth() + 1;

      if (month >= 3 && month <= 5) {
        return "Spring";
      } else if (month >= 6 && month <= 8) {
        return "Summer";
      } else if (month >= 9 && month <= 11) {
        return "Fall";
      } else {
        return "Winter";
      }
    }
    function getCensusRegion(state) {
      const censusRegions = {
        Northeast: [
          "Maine",
          "New Hampshire",
          "Vermont",
          "Massachusetts",
          "Rhode Island",
          "Connecticut",
          "New York",
          "New Jersey",
          "Pennsylvania",
        ],
        Midwest: [
          "Ohio",
          "Indiana",
          "Illinois",
          "Michigan",
          "Wisconsin",
          "Minnesota",
          "Iowa",
          "Missouri",
          "North Dakota",
          "South Dakota",
          "Nebraska",
          "Kansas",
        ],
        South: [
          "Delaware",
          "Maryland",
          "District of Columbia",
          "Virginia",
          "West Virginia",
          "North Carolina",
          "South Carolina",
          "Georgia",
          "Florida",
          "Kentucky",
          "Tennessee",
          "Mississippi",
          "Alabama",
          "Oklahoma",
          "Texas",
          "Arkansas",
          "Louisiana",
        ],
        West: [
          "Montana",
          "Idaho",
          "Wyoming",
          "Colorado",
          "New Mexico",
          "Arizona",
          "Utah",
          "Nevada",
          "California",
          "Oregon",
          "Washington",
          "Alaska",
          "Hawaii",
        ],
      };

      for (const region in censusRegions) {
        if (censusRegions[region].includes(state)) {
          return region;
        }
      }
      return null;
    }

    function createTable(data, sortColumn, sortOrder) {
      // Convert object to array of key-value pairs
      data = Object.entries(data);

      // Create table element and table header
      const table = document.createElement("table");
      table.className = "stateWiseData fadeInUp";
      const header = table.createTHead();
      const row = header.insertRow(0);
      const headers = [
        "State",
        "A",
        "B",
        "C",
        "Spring",
        "Summer",
        "Fall",
        "Winter",
      ];

      // Add table header cells with click event listener for sorting
      for (let i = 0; i < headers.length; i++) {
        const cell = row.insertCell(i);
        cell.innerHTML = headers[i];
        cell.addEventListener("click", () => {
          let order = sortOrder === "asc" ? "desc" : "asc";
          createTable(data, i, order);
        });
      }

      // Sort the data by the specified column and order
      data = data.sort((a, b) => {
        let valueA = a[1][headers[sortColumn]];
        let valueB = b[1][headers[sortColumn]];
        if (typeof valueA === "string") {
          valueA = valueA.toLowerCase();
          valueB = valueB.toLowerCase();
        }
        if (valueA < valueB) {
          return sortOrder === "asc" ? -1 : 1;
        }
        if (valueA > valueB) {
          return sortOrder === "asc" ? 1 : -1;
        }
        return 0;
      });

      // Add table body rows
      for (const [state, stateData] of data) {
        const row = table.insertRow();
        const values = [
          state,
          stateData.classACount,
          stateData.classBCount,
          stateData.classCCount,
          (stateData.seasonCount && stateData.seasonCount["Spring"]) || "-",
          (stateData.seasonCount && stateData.seasonCount["Summer"]) || "-",
          (stateData.seasonCount && stateData.seasonCount["Fall"]) || "-",
          (stateData.seasonCount && stateData.seasonCount["Winter"]) || "-",
        ];

        for (let i = 0; i < values.length; i++) {
          const cell = row.insertCell(i);
          cell.innerHTML = values[i];
          if (i > 0) {
            cell.style.textAlign = "right";
          }
        }

        // Add event listener to row for hover event
        row.addEventListener("mouseover", () => {
          const elements = document.getElementsByClassName(state);
          for (let i = 0; i < elements.length; i++) {
            // elements[i].setAttribute("stroke-width", "4.5");
          }
        });
      }

      return table;
    }

    const table = createTable(stateData1);
    document.getElementById("statesTable").appendChild(table);
    // document.body.appendChild(table);

    // ---------------------------------------------------------------------

    states = [...new Set(data.map((d) => d.state))]; // get unique states from data
    stateCountA = Object.fromEntries(states.map((s) => [s, 0])); // initialize counts to 0
    stateCountB = Object.fromEntries(states.map((s) => [s, 0]));
    stateCountC = Object.fromEntries(states.map((s) => [s, 0]));
    stateCount = Object.fromEntries(states.map((s) => [s, 0]));

    for (let i = 0; i < data.length; i++) {
      const state = data[i].state;
      if (data[i].classification === "Class A") {
        stateCountA[state]++;
      } else if (data[i].classification === "Class B") {
        stateCountB[state]++;
      } else if (data[i].classification === "Class C") {
        stateCountC[state]++;
      }
      stateCount[state] =
        stateCountA[state] + stateCountB[state] + stateCountC[state];
    }

    data = data.filter((d) => {
      return USA_states.includes(d.state);
    });

    // Create a color scale
    var allContinent = d3
      .map(data, function (d) {
        return d.classification;
      })
      .keys();

    // color palette
    color = d3
      .scaleOrdinal()
      .domain(allContinent)
      .range([
        "#377eb8",
        "#e41a1c",
        "#4daf4a",
        "#984ea3",
        "#ff7f00",
        "#ffff33",
        "#a65628",
        "#f781bf",
        "#999999",
      ]);

    // Define the color scale with a ratio of 2:3 red and blue
    const colorScale = d3
      .scaleLinear()
      .domain([0, 1])
      .range(["#FF0000", "#0000FF"])
      .interpolate(d3.interpolateHsl);

    // Add a scale for bubble size
    var valueExtent = d3.extent(data, function (d) {
      return +d.number;
    });
    var size = d3.scaleSqrt().domain(valueExtent).range([1, 50]);

    var zoom = d3.zoom().scaleExtent([1, 8]).on("zoom", zoomed);

    // svg.call(zoom);

    function zoomed() {
      g.attr("transform", d3.event.transform);
    }
    var g = svg
      .append("g")
      .selectAll("path")
      .data(dataGeo.features)
      .enter()
      .append("path")
      .attr("fill", function (d) {
        var opacity = stateCount[d.properties["NAME"]];
        return myColor(opacity);
      })
      .attr("class", function (d) {
        return d.properties["NAME"];
      })
      .attr("d", d3.geoPath().projection(projection))
      .style("stroke", 1)
      .attr("stroke", "black");

    // create a tooltip
    var Tooltip = d3
      .select("#my_dataviz")
      .append("div")
      .attr("class", "tooltip")
      .style("opacity", 0)
      .style("background-color", "white")
      .style("border", "solid")
      .style("border-width", "2px")
      .style("border-radius", "5px")
      .style("padding", "5px")
      .style("margin-right", "15px");

    // Three function that change the tooltip when user hover / move / leave a cell
    var mouseover = function (d) {
      d3.select(this).attr("cursor", "pointer");

      d3.select(this)
        .transition()
        .duration(100)
        .attr("transform", function (d) {
          const x = projection([+d.longitude, +d.latitude])[0];
          const y = projection([+d.longitude, +d.latitude])[1];
          return `translate(${x - 5}, ${y - 5}) scale(0.09)`;
        })
        .ease(d3.easeQuadIn);

      Tooltip.style("opacity", 1);
      Tooltip.style("display", "block");
    };

    var mousemove = function (d) {
      Tooltip.html(
        d.title +
          "<br>" +
          d.state +
          "<br>" +
          getYearAndSeason(d.timestamp).season +
          ", " +
          getYearAndSeason(d.timestamp).year +
          "<br>" +
          "classification: " +
          d.classification +
          "<br>" +
          "long: " +
          d.longitude +
          "<br>" +
          "lat: " +
          d.latitude
      );
      // .style("background", "hsl(230, 29%, 19%)")
      // .style("left", d3.mouse(this)[0] + 10 + "px")
      // .style("top", d3.mouse(this)[1] + "px");
    };
    var mouseleave = function (d) {
      Tooltip.style("opacity", 0);

      Tooltip.style("display", "none");
      d3.select(this)
        // .transition()
        // .duration(0)
        .attr("transform", function (d) {
          const x = projection([+d.longitude, +d.latitude])[0];
          const y = projection([+d.longitude, +d.latitude])[1];
          return `translate(${x}, ${y}) scale(0.05)`;
        });
    };

    // ---------- BIGFOOT GLYPH -----------
    svg
      .selectAll("path")
      .data(data)
      .enter()
      .each(function (d) {
        if (d.classification) {
          const x = projection([+d.longitude, +d.latitude])[0];
          const y = projection([+d.longitude, +d.latitude])[1];
          const sasquatch =
            "m242,170c-0.8,0.5 -1.6,1.1 -2.8,1.9c-2.3,0 -5.1,0 -8,0c-0.1,0.6 -0.2,1 -0.4,1.9c-2.6,0.7 -5.4,1.5 -8.3,2.1c-3.1,0.7 -6,-1.2 -9.1,-1c-0.7,-1.2 -2.1,-1.8 -2.6,-3.4c-0.7,-2.3 -2.5,-3.7 -4.9,-4.6c-2.3,-0.8 -4.4,-2.4 -6.8,-2.8c-2.5,-0.4 -4.2,-2 -6.4,-2.7c-1.3,-0.5 -2.9,-0.4 -4.2,-0.9c-2.6,-0.8 -5.7,-1.1 -7.8,-2.7c-2.2,-1.5 -5.3,-1.9 -6.4,-4.8c-3.7,0.3 -4.3,-3.8 -7.7,-5c-2.3,-0.3 -5.4,-2.4 -8.2,-0.2c-1.9,-0.3 -3.5,-0.7 -5,-0.9c-2.2,2.4 -2.9,5.6 -6.2,6.3c-0.9,2.1 -1.9,4.3 -2.8,6.4c-1,2.3 -0.2,4.4 1,6.6c1.1,2 2,4.1 2.7,6.4c0.7,2.3 2,4.6 4,6.3c1.1,0.9 2,2.2 2.4,3.5c0.5,1.6 0.8,3 2.2,4.2c0.3,0.3 0.1,1.3 0.2,2c2.2,2.5 5.1,4.8 6.4,7.8c1.2,2.9 3,5.4 4.6,8.6c-0.3,2.6 0.9,4.9 2.5,7.5c1.9,3 3,6.5 5.5,9.2c-0.2,2.1 2.2,2.3 2.8,3.9c-0.3,5 1.8,9.8 1.3,14.9c-0.1,1.3 0.4,2.8 1,4.1c1.4,2.8 0.2,6.4 2.7,8.9c-0.5,2.9 2.7,5.6 0.2,8.6c0.4,2.5 -0.8,5.2 0.9,7.7c0.5,0.7 0.1,1.9 0.1,2.9c0,4.8 0,9.7 0,14.5c0,2.6 -0.3,5.1 1.6,7.4c0.6,0.7 0.3,2.2 0.5,3.7c3.2,1.9 6.7,3.9 10.4,6c2.5,0 5.2,-0.1 7.9,0c1.4,0 2.9,-0.5 4.2,0.9c0.4,0.4 2,-0.3 3.9,-0.6c0.7,0.2 2.4,0.6 3.8,1c1.3,1.1 2.5,2.2 4,3.5c-1.7,2.1 -3.3,3.9 -5.6,5.3c-1.6,1 -3,2.6 -4.5,3.7c-1.8,1.4 -4.5,1.9 -6.6,3.2c-1.7,1 -3.6,1.8 -6.2,3c-4,0 -9,0 -14,0c-3.9,0 -5.6,0.5 -10.1,3.1c-5.4,-0.6 -11.2,1 -16.8,-1.1c-1.4,-3.2 -3.4,-6.1 -4,-9.8c-0.1,-1 -0.5,-2.2 -0.5,-3.2c-0.1,-4.5 -0.1,-9 0,-13.5c0.1,-3.6 -0.7,-6.9 -2,-10.2c-0.7,-1.7 -0.6,-3.7 -1.1,-5.6c-0.9,-3.2 -2.4,-6 -4.4,-8.7c-2.2,-2.9 -4.8,-5.5 -6,-9c-0.6,-1.6 -1,-3.2 -1.6,-4.9c-0.2,-0.6 -0.5,-1.1 -1.3,-1.6c0,-5.8 0,-11.6 0,-17.3c0,-0.2 -0.4,-0.5 -0.8,-0.8c3.5,-1.4 -1.6,-4.1 0.9,-5.7c-1.1,-4.5 -5.8,-5.6 -8.3,-8.7c-0.9,0 -1.8,0 -2.4,0c-1.2,1.3 -2.3,2.5 -3.9,4.1c-0.3,1.1 -0.8,3 -1.3,4.7c-0.9,0.2 -1.3,0.3 -1.8,0.4c0,1.4 0,2.8 0,3.6c-1.5,2.2 -3.6,3.9 -3.9,5.8c-0.4,3.1 -2.4,4.8 -4,6.6c-0.5,4.2 -4.5,6.3 -5.2,10.4c-1.3,0.5 -2.7,1 -5.1,1.9c-1,0.9 -3,2.2 -4.9,3.6c-2.3,1.6 -4.7,3.3 -6.8,5.2c-1.3,1.1 -2.8,2.1 -4.2,3.2c-2.1,1.7 -4.5,3.3 -6.2,5.4c-2.4,3 -6,4.3 -8.9,6.4c-2.3,1.7 -3.3,4 -4.8,6.1c-0.3,0.4 -0.7,0.7 -1,1.1c0,1.6 0,3.3 0,5c3.8,3.5 9.2,3.6 13.5,6.1c2.4,0.5 4.9,1 7.1,1.4c1.9,2 2.9,4.1 2.1,6.9c-1.7,0.9 -3.5,1.9 -5.2,2.8c-3.9,0.4 -7.7,0.8 -11.6,1.2c-0.3,0 -0.6,0.2 -0.9,0.3c-3,1.9 -6.4,1.7 -9.8,1.7c-2.2,0 -4.3,0 -6.2,0c-6.3,-2.6 -12.4,-5 -18.1,-9.8c-3.6,0.8 -5.9,-3.4 -9.6,-4.3c-1.1,-1.8 -2.2,-3.5 -3.5,-5.5c0,-1.7 0,-3.7 0,-5.7c0,-1.1 0.1,-2.3 0.2,-3.4c0.1,-0.6 0.4,-1.5 0.8,-1.6c1.9,-0.6 2,-3.3 3.4,-3.4c2.5,-0.3 2.1,-3.6 4.5,-3.6c2,-3 3.7,-6.4 6.3,-8.8c2.6,-2.4 3.8,-5.5 6.3,-8c2.5,-2.6 4.1,-6.2 5.5,-9.6c0.9,-2.2 2.2,-3.9 3.9,-5.4c3.1,-2.7 5.6,-5.9 9,-8.3c2.1,-1.5 4.4,-1.8 6.6,-2.3c4.2,-0.9 7.9,-2.2 10.7,-5.7c0,-1.5 0,-2.9 -1.3,-4.4c-1.1,-1.3 -1.4,-3.4 -1.7,-5.2c-0.3,-2.4 -0.1,-4.7 -0.9,-7.1c-0.9,-2.5 -0.9,-5.3 -1.1,-8c-0.2,-2.7 -0.1,-5.3 0,-8c0,-0.7 0.5,-1.4 0.8,-2.2c-0.4,-0.8 -0.8,-1.9 -1.6,-2.6c-2.2,-1.8 -4.5,-3.5 -7.1,-5.4c-1.5,-3.1 -3.1,-6.6 -5.3,-11.3c-0.5,-1.8 -0.4,-5.2 -1.6,-8.4c1.5,-3.4 0.5,-7 0.8,-10.5c0.3,-3.3 0.6,-6.7 0.6,-10.1c-1,2.6 -5.1,2.8 -4.8,6.5c-1.5,1.5 -3.1,3.1 -4.1,4.1c-1.6,3.3 -2.9,5.9 -4.5,9c-2.7,2 -6.2,4.2 -9.2,6.9c-1.8,1.6 -3.7,2.9 -5.9,3.8c-3.1,1.3 -6.2,2.8 -9.3,4.2c-4.7,2.1 -7.4,2 -11.5,-0.7c-2.3,-1.5 -4.3,-3.4 -5.6,-4.5c-1.8,-4.5 -3.3,-8.1 -4.7,-11.5c0.4,-2.1 0.8,-4.1 1.3,-6.5c0.8,-0.8 2,-1.9 3.7,-3.4c1.2,0.2 3,0.5 5.4,0.8c1.9,-1 4.5,-1.8 6.9,-3.4c3.4,-2.1 5,-5.2 6.4,-8.4c1.7,-3.9 3.2,-8 5.1,-11.9c0.7,-1.4 1.9,-2.5 2.6,-3.4c2.7,-6.4 6.8,-11.9 6.3,-19c2.1,-2.6 4.7,-4.9 6.4,-8.2c1.6,-3.1 4.8,-5.5 8.6,-6.5c1.4,-0.4 1.8,-2.2 3.3,-2.7c1,-0.4 2.6,-0.4 3,-1.1c1.4,-2.6 4.5,-3.3 5.8,-6c1.1,-2.1 2.7,-3.9 4.1,-5.8c0.4,-0.5 0.7,-1.1 0.8,-1.7c0.5,-3.5 3,-5.9 5.7,-7.5c2.5,-1.5 3.1,-3.3 3.4,-5.7c0,-0.3 0,-0.7 0,-1c0,-0.1 0.2,-0.2 0.3,-0.4c0.5,-0.5 0.9,-0.9 1.6,-1.6c0,-1.3 0,-2.7 0,-3.7c1.7,-2.7 3.1,-5 5.3,-6.8c2.5,-2 4.9,-3.7 8.1,-2.9c1.8,-3.3 5.9,-4.2 6.8,-7.7c2.1,-1.1 4.2,-2.1 6.7,-3.4c1.8,0 4.2,0 6.3,0c1.4,-1.1 2.6,-2.1 3.9,-3c1.3,-0.9 2.8,-1.7 3,-3.6c1.2,-0.5 2.4,-1.1 3.8,-1.7c0,-0.6 0.1,-1.2 0.1,-1.8c2.6,-3.9 6.1,-7.2 8.4,-11.5c1.6,-2.9 4.8,-4.9 7.3,-7.3c0.7,-0.7 1.4,-1.5 2.2,-2.1c0.9,-0.7 2,-1.7 3,-1.7c1.6,0 2.3,-1 3.3,-1.9c1.4,-1 3.6,1.1 4.7,-1.2c1.3,0 2.7,0 4,0c0.4,0.3 0.8,0.8 1.3,1c1.2,0.3 2.6,0.1 3.7,0.6c4.9,2.3 7.5,6.8 9.9,11.3c0.5,0.9 0.1,2.6 0.7,3.1c1.7,1.4 1.8,3.5 2.1,5.1c0.4,1.7 1.7,2.3 2.1,3.6c0.5,1.8 -0.9,4 1,5.6c0.3,3.8 0.6,7.5 -2.5,9.8c-0.6,3.5 -1,6.5 -1.5,9.5c-0.6,0.6 -1.2,1.2 -1.9,1.9c0,2.9 0,6.1 0,9.2c-1.1,0.6 -2,1.2 -2.9,1.7c0,1 0,2 0,3.6c0.8,0.7 2,1.6 3.1,2.5c0,1.1 0,2.1 0,3c0.7,0.7 1.3,1.3 1.9,1.9c0,4.3 0.1,8.6 0,13c-0.1,2.4 0.5,4.4 2.1,6.2c1.4,1.5 3.3,3.1 3.8,4.9c1,3.9 3.6,7.3 3.3,11.5c1.6,0.7 3.4,0.8 4,1.8c1.2,1.9 3.2,2.9 4.7,4.4c1.8,1.7 3.9,3.1 5.9,4.5c2.3,3.4 5.5,6 8.4,8.9c3,3 6.3,5.7 9.2,8.3c2.6,0.5 4.9,1 7.4,1.4c1.4,1.1 2.8,2.6 4.5,3.3c2.1,0.9 2.9,2.9 4,4.4c1.2,1.8 2.7,2.9 4.5,4c0.3,3.2 2.1,5.7 4.2,7.9c0.5,1.4 0.5,3.4 0.5,5.4z";
          const path = svg
            .append("path")
            .attr("d", sasquatch)
            .attr(
              "transform",
              `translate(${projection([
                +d.longitude,
                +d.latitude,
              ])}) scale(0.05)`
            )
            // .classed(`${d.state}`, true)
            // .classed(`${d.classification}`, true)
            .classed(
              `bigFootLabel_${d.classification.replace(" ", "")} allLabels`,
              true
            )
            .attr("id", "bigFootLabel")
            // .style("fill", getYearAndSeason(d.timestamp).color)
            .style("fill", color(d.classification))
            .attr("stroke", "black")
            .attr("stroke-width", 15)
            .attr("fill-opacity", 0.5)
            // .style("filter", "drop-shadow(0 0 5px rgba(255, 255, 255, 0.5))")
            // .style("mix-blend-mode", "overlay")
            .on("mouseover", mouseover)
            .on("mousemove", mousemove)
            .on("mouseleave", mouseleave);

          //   setInterval(function () {
          //     path.style(
          //       "visibility",
          //       path.style("visibility") === "hidden" ? "visible" : "hidden"
          //     );
          //   }, 500);
        }
      });

    svg.selectAll("path").data(data).enter();

    const seasons = ["Winter", "Spring", "Summer", "Fall"];
    const seasonReports = {};

    // group reports by season and classification
    data.reduce((acc, report) => {
      const timestamp = new Date(report.timestamp);
      const seasonIndex = Math.floor(timestamp.getMonth() / 3);
      const season = seasons[seasonIndex];
      const classification = report.classification;

      if (!acc[season]) {
        acc[season] = { "Class A": 0, "Class B": 0, "Class C": 0 };
      }
      acc[season][classification]++;

      return acc;
    }, seasonReports);

    // calculate percentages for each season and classification
    for (const season in seasonReports) {
      const total = Object.values(seasonReports[season]).reduce(
        (acc, count) => acc + count,
        0
      );
      for (const classification in seasonReports[season]) {
        seasonReports[season][classification] =
          ((seasonReports[season][classification] / total) * 100).toFixed(2) +
          "%";
      }
    }

    // -----------------------------------------------------------------------

    const resultantData = {};
    for (const state in stateData) {
      const region = getCensusRegion(state);
      if (!region) continue; // skip if state not found in any region
      if (!resultantData[region]) {
        resultantData[region] = {
          total: 0,
          classificationCount: {},
        };
      }
      const stateDataNew = stateData[state];
      resultantData[region]["total"] += stateDataNew["total"];
      for (const classification in stateDataNew["classificationCount"]) {
        if (!resultantData[region]["classificationCount"][classification]) {
          resultantData[region]["classificationCount"][classification] = 0;
        }
        resultantData[region]["classificationCount"][classification] +=
          parseInt(stateDataNew["classificationCount"][classification]);
      }
    }

    drawPie(censusDataAll["allClasses"], "ClassD");
  }
</script>
